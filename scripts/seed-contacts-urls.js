#!/usr/bin/env node
/**
 * Multi-Company URL Seeder - Common Crawl Index
 *
 * Discovers distributor URLs for multiple direct sales companies from
 * Common Crawl Index and seeds them into the direct_sales_contacts
 * Firestore collection.
 *
 * Usage:
 *   node scripts/seed-contacts-urls.js                      # Seed all companies with patterns
 *   node scripts/seed-contacts-urls.js --company=Herbalife  # Seed specific company
 *   node scripts/seed-contacts-urls.js --company=doTERRA --max=100
 *
 * Environment variables:
 *   DRY_RUN - If "true", don't write to Firestore (preview only)
 *   MAX_URLS - Maximum URLs to seed per company (default: 10000)
 *
 * Data source: Common Crawl Index API (no API key required)
 * Patterns: patterns.json (generated by base_url_discovery.js)
 */

const admin = require('firebase-admin');
const fs = require('fs');
const path = require('path');

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
  // Pattern file
  PATTERNS_FILE: path.join(__dirname, 'patterns.json'),

  // Common Crawl Index - comprehensive list of indexes to search
  COMMON_CRAWL_INDEXES: [
    // 2026
    'CC-MAIN-2026-04',
    // 2025 (all available)
    'CC-MAIN-2025-51',
    'CC-MAIN-2025-47',
    'CC-MAIN-2025-43',
    'CC-MAIN-2025-38',
    'CC-MAIN-2025-33',
    'CC-MAIN-2025-30',
    'CC-MAIN-2025-26',
    'CC-MAIN-2025-21',
    'CC-MAIN-2025-18',
    'CC-MAIN-2025-13',
    'CC-MAIN-2025-08',
    'CC-MAIN-2025-05',
    // 2024 (all available)
    'CC-MAIN-2024-51',
    'CC-MAIN-2024-46',
    'CC-MAIN-2024-42',
    'CC-MAIN-2024-38',
    'CC-MAIN-2024-33',
  ],
  COMMON_CRAWL_BASE: 'https://index.commoncrawl.org',

  // Firestore
  COLLECTION: 'direct_sales_contacts',
  SOURCE: 'common_crawl',

  // Rate limiting
  DELAY_BETWEEN_REQUESTS: 1000,
  MAX_URLS_PER_COMPANY: 10000,

  // Paths/files to exclude
  EXCLUDED_PATHS: [
    'robots.txt', 'sitemap', 'favicon',
    '/login', '/signin', '/register', '/signup', '/account',
    '/cart', '/checkout', '/admin', '/api/', '/cdn-cgi/',
    '/privacy', '/terms', '/about', '/contact', '/careers',
    '/press', '/blog', '/news', '/help', '/support', '/faq',
    '.pdf', '.jpg', '.png', '.gif', '.css', '.js', '.xml',
  ],

  // Company name mappings (domain -> display name)
  COMPANY_NAMES: {
    'herbalife.com': 'Herbalife',
    'doterra.com': 'doTERRA',
    'arbonne.com': 'Arbonne',
    'monatglobal.com': 'Monat',
    'scentsy.com': 'Scentsy',
    'ambitenergy.com': 'Ambit Energy',
    'shaklee.com': 'Shaklee',
    'lifewave.com': 'LifeWave',
    'pruvitnow.com': 'Pruvit',
    'zilis.com': 'Zilis',
    'nuskin.com': 'Nu Skin',
    'usana.com': 'USANA',
    'youngliving.com': 'Young Living',
    'isagenix.com': 'Isagenix',
    'itworks.com': 'It Works!',
    'amway.com': 'Amway',
    'marykay.com': 'Mary Kay',
    'primerica.com': 'Primerica',
    'foreverliving.com': 'Forever Living',
    'avon.com': 'Avon',
  },
};

// ============================================================================
// FIREBASE INITIALIZATION
// ============================================================================

function initializeFirebase() {
  const serviceAccountPath = path.join(__dirname, '..', 'secrets', 'serviceAccountKey.json');

  if (!admin.apps.length) {
    admin.initializeApp({
      credential: admin.credential.cert(require(serviceAccountPath))
    });
  }

  return admin.firestore();
}

// ============================================================================
// PATTERN LOADING
// ============================================================================

function loadPatterns() {
  if (!fs.existsSync(CONFIG.PATTERNS_FILE)) {
    throw new Error(`Patterns file not found: ${CONFIG.PATTERNS_FILE}\nRun base_url_discovery.js first.`);
  }
  return JSON.parse(fs.readFileSync(CONFIG.PATTERNS_FILE, 'utf8'));
}

function getCompanyName(domain) {
  return CONFIG.COMPANY_NAMES[domain] || domain.replace('.com', '').replace(/\./g, ' ')
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

// ============================================================================
// COMMON CRAWL INDEX QUERY
// ============================================================================

/**
 * Query Common Crawl Index for URLs matching pattern
 */
async function queryCommonCrawlIndex(indexName, urlPattern) {
  const urls = [];
  const indexUrl = `${CONFIG.COMMON_CRAWL_BASE}/${indexName}-index`;
  const queryUrl = `${indexUrl}?url=${encodeURIComponent(urlPattern)}&output=json`;

  try {
    const response = await fetch(queryUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (compatible; TBP-URL-Seeder/1.0)',
      },
    });

    if (!response.ok) {
      if (response.status === 404) {
        return urls;
      }
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const text = await response.text();
    if (!text.trim()) return urls;

    // Common Crawl returns JSONL (one JSON object per line)
    const lines = text.trim().split('\n').filter(line => line.trim());

    for (const line of lines) {
      try {
        const record = JSON.parse(line);
        if (record.url) {
          urls.push(record.url);
        }
      } catch {
        // Skip malformed lines
      }
    }

  } catch (error) {
    console.log(`    Error querying ${indexName}: ${error.message}`);
  }

  return urls;
}

/**
 * Query multiple Common Crawl indexes and merge results
 */
async function discoverUrlsFromCommonCrawl(pattern) {
  const allUrls = new Set();

  console.log(`  Pattern: ${pattern}`);

  for (const indexName of CONFIG.COMMON_CRAWL_INDEXES) {
    console.log(`    Querying ${indexName}...`);
    const urls = await queryCommonCrawlIndex(indexName, pattern);
    urls.forEach(url => allUrls.add(url));

    console.log(`    Found ${urls.length} URLs (total unique: ${allUrls.size})`);

    // Rate limit between index queries
    await sleep(CONFIG.DELAY_BETWEEN_REQUESTS);

    // Stop if we have enough URLs
    if (allUrls.size >= CONFIG.MAX_URLS_PER_COMPANY) {
      console.log(`    Reached max URLs limit (${CONFIG.MAX_URLS_PER_COMPANY})`);
      break;
    }
  }

  console.log(`  Total unique URLs discovered: ${allUrls.size}`);

  return allUrls;
}

// ============================================================================
// URL NORMALIZATION & VALIDATION
// ============================================================================

/**
 * Normalize URL based on pattern type
 */
function normalizeUrl(url, patternInfo) {
  try {
    const parsed = new URL(url);
    const hostname = parsed.hostname.toLowerCase();
    const pathname = parsed.pathname;

    // Check for excluded paths
    const lowerUrl = url.toLowerCase();
    for (const excluded of CONFIG.EXCLUDED_PATHS) {
      if (lowerUrl.includes(excluded)) return null;
    }

    if (patternInfo.type === 'subdomain') {
      // For subdomain patterns, extract the base hostname
      // Skip bare domain without subdomain
      const parts = hostname.split('.');
      if (parts.length < 3) return null;

      // Skip www
      if (parts[0] === 'www') return null;

      // Return just the homepage for the subdomain
      return `https://${hostname}`;

    } else if (patternInfo.type === 'path') {
      // For path patterns, normalize the path
      const pathParts = pathname.split('/').filter(p => p);

      if (pathParts.length === 0) return null;

      // Get the first path segment (typically username/ID)
      const username = pathParts[0];

      // Skip locale/language codes and corporate pages
      const skipPatterns = [
        /^(en|es|de|fr|pt|it|ja|ko|zh|ru)[-_]/i,  // Locale codes
        /^(en|es|de|fr|pt|it|ja|ko|zh|ru)$/i,      // Single locale
        /^(catalog|content|corp|products|apps|hub|Main|webhosting)$/i,
      ];

      for (const skipPattern of skipPatterns) {
        if (skipPattern.test(username)) return null;
      }

      // Username should be alphanumeric
      if (!/^[a-zA-Z0-9_-]+$/.test(username)) return null;
      if (username.length < 3) return null;

      // Return normalized URL
      return `https://${hostname.replace(/^www\./, '')}/${username}`;

    } else if (patternInfo.type === 'third-party') {
      // Handle third-party platforms (like Zilis on Elify)
      // Keep the full path structure
      const pathParts = pathname.split('/').filter(p => p);
      if (pathParts.length < 2) return null;

      const username = pathParts[pathParts.length - 1];
      if (!/^[a-zA-Z0-9_-]+$/.test(username)) return null;

      return `https://${hostname}${pathname.replace(/\/$/, '')}`;
    }

    return null;
  } catch {
    return null;
  }
}

// ============================================================================
// FIRESTORE OPERATIONS
// ============================================================================

/**
 * Load existing URLs from Firestore for a specific company
 */
async function loadExistingUrls(db, companyName) {
  console.log(`  Loading existing URLs for ${companyName}...`);

  const existingUrls = new Set();
  const snapshot = await db.collection(CONFIG.COLLECTION)
    .where('company', '==', companyName)
    .select('url')
    .get();

  snapshot.forEach(doc => {
    const url = doc.data().url;
    if (url) {
      existingUrls.add(url);
    }
  });

  console.log(`  Found ${existingUrls.size} existing URLs in Firestore`);

  return existingUrls;
}

/**
 * Insert new URLs into Firestore
 */
async function insertUrls(db, urls, companyName, dryRun) {
  if (urls.length === 0) {
    console.log('  No new URLs to insert');
    return 0;
  }

  console.log(`  Inserting ${urls.length} new URLs...`);

  if (dryRun) {
    console.log('  DRY RUN - Would insert the following URLs:');
    urls.slice(0, 10).forEach(url => console.log(`    ${url}`));
    if (urls.length > 10) {
      console.log(`    ... and ${urls.length - 10} more`);
    }
    return 0;
  }

  let batch = db.batch();
  let batchCount = 0;
  let totalInserted = 0;

  for (const url of urls) {
    const docRef = db.collection(CONFIG.COLLECTION).doc();

    batch.set(docRef, {
      // URL & Source
      url: url,
      normalizedUrl: url,
      source: CONFIG.SOURCE,
      company: companyName,

      // Contact Info (null until scraped)
      firstName: null,
      lastName: null,
      email: null,

      // Scrape Status
      scraped: false,
      scrapedAt: null,
      scrapeStatus: 'pending',
      scrapeError: null,
      scrapeAttempts: 0,
      lastAttemptAt: null,

      // Metadata
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    });

    batchCount++;
    totalInserted++;

    // Firestore batch limit is 500
    if (batchCount >= 500) {
      await batch.commit();
      console.log(`    Committed batch of ${batchCount} URLs (total: ${totalInserted})`);
      batch = db.batch();
      batchCount = 0;
    }
  }

  // Commit remaining
  if (batchCount > 0) {
    await batch.commit();
    console.log(`    Committed final batch of ${batchCount} URLs (total: ${totalInserted})`);
  }

  return totalInserted;
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function parseArgs() {
  const args = process.argv.slice(2);
  const options = {
    company: null,
    maxUrls: process.env.MAX_URLS ? parseInt(process.env.MAX_URLS, 10) : CONFIG.MAX_URLS_PER_COMPANY,
    dryRun: process.env.DRY_RUN === 'true',
  };

  for (const arg of args) {
    if (arg.startsWith('--company=')) {
      options.company = arg.split('=')[1];
    } else if (arg.startsWith('--max=')) {
      options.maxUrls = parseInt(arg.split('=')[1], 10);
    } else if (arg === '--dry-run') {
      options.dryRun = true;
    }
  }

  return options;
}

// ============================================================================
// PROCESS SINGLE COMPANY
// ============================================================================

async function processCompany(db, companyDomain, patternInfo, options) {
  const companyName = getCompanyName(companyDomain);

  console.log(`\n${'='.repeat(60)}`);
  console.log(`Processing: ${companyName} (${companyDomain})`);
  console.log('='.repeat(60));

  // Skip if no pattern or marked as no-email platform
  if (!patternInfo.pattern || patternInfo.urlCount === 0) {
    console.log('  Skipping: No pattern discovered');
    return { company: companyName, discovered: 0, inserted: 0, skipped: true };
  }

  if (patternInfo.noEmailPlatform) {
    console.log('  Skipping: Marked as no-email platform');
    return { company: companyName, discovered: 0, inserted: 0, skipped: true };
  }

  // Discover URLs from Common Crawl
  console.log('\n  Discovering URLs from Common Crawl...');
  const discoveredUrls = await discoverUrlsFromCommonCrawl(patternInfo.pattern);

  // Normalize and validate URLs
  console.log('\n  Normalizing and validating URLs...');
  const validUrls = new Set();

  for (const url of discoveredUrls) {
    const normalized = normalizeUrl(url, patternInfo);
    if (normalized) {
      validUrls.add(normalized);
    }
  }

  console.log(`  Valid URLs after normalization: ${validUrls.size}`);

  // Load existing URLs for deduplication
  const existingUrls = await loadExistingUrls(db, companyName);

  // Filter out duplicates
  const newUrls = Array.from(validUrls).filter(url => !existingUrls.has(url));
  console.log(`  New URLs (not in Firestore): ${newUrls.length}`);

  // Apply max limit
  const urlsToInsert = newUrls.slice(0, options.maxUrls);
  if (newUrls.length > options.maxUrls) {
    console.log(`  Limited to ${options.maxUrls} URLs`);
  }

  // Insert into Firestore
  const insertedCount = await insertUrls(db, urlsToInsert, companyName, options.dryRun);

  return {
    company: companyName,
    discovered: discoveredUrls.size,
    valid: validUrls.size,
    new: newUrls.length,
    inserted: insertedCount,
    skipped: false,
  };
}

// ============================================================================
// MAIN EXECUTION
// ============================================================================

async function main() {
  const startTime = Date.now();
  const options = parseArgs();

  console.log('='.repeat(60));
  console.log('MULTI-COMPANY URL SEEDER - Common Crawl Index');
  console.log('='.repeat(60));
  console.log(`Mode: ${options.dryRun ? 'DRY RUN' : 'LIVE'}`);
  console.log(`Max URLs per company: ${options.maxUrls}`);
  console.log(`Timestamp: ${new Date().toISOString()}`);

  // Load patterns
  const patterns = loadPatterns();
  console.log(`Loaded ${Object.keys(patterns).length} company patterns`);

  // Initialize Firebase
  const db = initializeFirebase();

  // Determine which companies to process
  let companiesToProcess;
  if (options.company) {
    // Find the company by name or domain
    const companyLower = options.company.toLowerCase();
    companiesToProcess = Object.entries(patterns).filter(([domain, _]) => {
      const name = getCompanyName(domain).toLowerCase();
      return domain.includes(companyLower) || name.includes(companyLower);
    });

    if (companiesToProcess.length === 0) {
      console.error(`Company not found: ${options.company}`);
      process.exit(1);
    }
  } else {
    // Process all companies with valid patterns
    companiesToProcess = Object.entries(patterns).filter(([_, p]) =>
      p.pattern && p.urlCount > 0 && !p.noEmailPlatform
    );
  }

  console.log(`Processing ${companiesToProcess.length} companies`);

  // Process each company
  const results = [];
  for (const [domain, patternInfo] of companiesToProcess) {
    const result = await processCompany(db, domain, patternInfo, options);
    results.push(result);

    // Rate limit between companies
    if (companiesToProcess.indexOf([domain, patternInfo]) < companiesToProcess.length - 1) {
      await sleep(CONFIG.DELAY_BETWEEN_REQUESTS * 2);
    }
  }

  // Summary
  const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
  const totalInserted = results.reduce((sum, r) => sum + (r.inserted || 0), 0);
  const totalDiscovered = results.reduce((sum, r) => sum + (r.discovered || 0), 0);

  console.log('\n' + '='.repeat(60));
  console.log('SEEDING COMPLETE');
  console.log('='.repeat(60));
  console.log(`Companies processed: ${results.length}`);
  console.log(`Total URLs discovered: ${totalDiscovered}`);
  console.log(`Total URLs inserted: ${totalInserted}`);
  console.log(`Time elapsed: ${elapsed}s`);
  console.log('='.repeat(60));

  // Per-company summary
  console.log('\nPer-company results:');
  for (const result of results) {
    if (result.skipped) {
      console.log(`  ${result.company}: SKIPPED`);
    } else {
      console.log(`  ${result.company}: ${result.inserted} inserted (${result.discovered} discovered, ${result.new} new)`);
    }
  }

  // Exit
  process.exit(0);
}

// Run
main().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
});
